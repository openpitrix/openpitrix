// Copyright 2018 The OpenPitrix Authors. All rights reserved.
// Use of this source code is governed by a Apache license
// that can be found in the LICENSE file.

// Auto generated by 'go run gen_helper.go', DO NOT EDIT.

package cluster

import (
	"context"

	"openpitrix.io/openpitrix/pkg/constants"
	"openpitrix.io/openpitrix/pkg/db"
	"openpitrix.io/openpitrix/pkg/gerr"
	"openpitrix.io/openpitrix/pkg/models"
	"openpitrix.io/openpitrix/pkg/pi"
	"openpitrix.io/openpitrix/pkg/util/ctxutil"
)

func CheckClustersPermission(ctx context.Context, resourceIds []string) ([]*models.Cluster, error) {
	if len(resourceIds) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var clusters []*models.Cluster
	_, err := pi.Global().DB(ctx).
		Select(models.ClusterColumns...).
		From(constants.TableCluster).
		Where(db.Eq(constants.ColumnClusterId, resourceIds)).Load(&clusters)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, cluster := range clusters {
			if !cluster.OwnerPath.CheckPermission(sender) && cluster.Owner != sender.UserId {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, cluster.ClusterId)
			}
		}
	}
	if len(clusters) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceIds)
	}
	return clusters, nil
}

func CheckClusterPermission(ctx context.Context, resourceId string) (*models.Cluster, error) {
	if len(resourceId) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var clusters []*models.Cluster
	_, err := pi.Global().DB(ctx).
		Select(models.ClusterColumns...).
		From(constants.TableCluster).
		Where(db.Eq(constants.ColumnClusterId, resourceId)).Load(&clusters)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, cluster := range clusters {
			if !cluster.OwnerPath.CheckPermission(sender) {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, cluster.ClusterId)
			}
		}
	}
	if len(clusters) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceId)
	}
	return clusters[0], nil
}

func CheckClusterNodesPermission(ctx context.Context, resourceIds []string) ([]*models.ClusterNode, error) {
	if len(resourceIds) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var clusternodes []*models.ClusterNode
	_, err := pi.Global().DB(ctx).
		Select(models.ClusterNodeColumns...).
		From(constants.TableClusterNode).
		Where(db.Eq(constants.ColumnNodeId, resourceIds)).Load(&clusternodes)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, clusternode := range clusternodes {
			if !clusternode.OwnerPath.CheckPermission(sender) && clusternode.Owner != sender.UserId {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, clusternode.NodeId)
			}
		}
	}
	if len(clusternodes) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceIds)
	}
	return clusternodes, nil
}

func CheckClusterNodePermission(ctx context.Context, resourceId string) (*models.ClusterNode, error) {
	if len(resourceId) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var clusternodes []*models.ClusterNode
	_, err := pi.Global().DB(ctx).
		Select(models.ClusterNodeColumns...).
		From(constants.TableClusterNode).
		Where(db.Eq(constants.ColumnNodeId, resourceId)).Load(&clusternodes)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, clusternode := range clusternodes {
			if !clusternode.OwnerPath.CheckPermission(sender) {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, clusternode.NodeId)
			}
		}
	}
	if len(clusternodes) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceId)
	}
	return clusternodes[0], nil
}

func CheckKeyPairsPermission(ctx context.Context, resourceIds []string) ([]*models.KeyPair, error) {
	if len(resourceIds) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var keypairs []*models.KeyPair
	_, err := pi.Global().DB(ctx).
		Select(models.KeyPairColumns...).
		From(constants.TableKeyPair).
		Where(db.Eq(constants.ColumnKeyPairId, resourceIds)).Load(&keypairs)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, keypair := range keypairs {
			if !keypair.OwnerPath.CheckPermission(sender) && keypair.Owner != sender.UserId {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, keypair.KeyPairId)
			}
		}
	}
	if len(keypairs) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceIds)
	}
	return keypairs, nil
}

func CheckKeyPairPermission(ctx context.Context, resourceId string) (*models.KeyPair, error) {
	if len(resourceId) == 0 {
		return nil, nil
	}
	var sender = ctxutil.GetSender(ctx)
	var keypairs []*models.KeyPair
	_, err := pi.Global().DB(ctx).
		Select(models.KeyPairColumns...).
		From(constants.TableKeyPair).
		Where(db.Eq(constants.ColumnKeyPairId, resourceId)).Load(&keypairs)
	if err != nil {
		return nil, gerr.NewWithDetail(ctx, gerr.Internal, err, gerr.ErrorInternalError)
	}
	if sender != nil {
		for _, keypair := range keypairs {
			if !keypair.OwnerPath.CheckPermission(sender) {
				return nil, gerr.New(ctx, gerr.PermissionDenied, gerr.ErrorResourceAccessDenied, keypair.KeyPairId)
			}
		}
	}
	if len(keypairs) == 0 {
		return nil, gerr.New(ctx, gerr.NotFound, gerr.ErrorResourceNotFound, resourceId)
	}
	return keypairs[0], nil
}
